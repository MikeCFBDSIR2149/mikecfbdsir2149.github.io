[
    {
        "id": 1,
        "title": "基于 SPH 算法的 SSF 流体模拟和交互",
        "summary": "使用 SPH（平滑粒子流体动力学）算法，对流体进行模拟，并支持和刚体的粗略交互。",
        "type": "personal",
        "public": true,
        "link": "https://github.com/MikeCFBDSIR2149/SPHSimulation",
        "content": [
        { "type": "text", "value": "在这个项目中，我尝试实现了较为高效 SPH（光滑粒子流体动力学）粒子模拟，并且实现粒子渲染和 SSF（表面空间流体）渲染，然后还添加了一定程度的固体流体交互功能。这个项目最后可以以单纯的 GPU 粒子或 SSF 渲染这两种形式观察模拟情况。" },
        { "type": "text", "value": "这个项目基于 Unity 6 URP。下图展示了代码逻辑整体流程。" },
        { "type": "image", "src": "../images/1-1.png", "alt": "代码逻辑整体流程" },
        { "type": "text", "value": "关于 SSF，这是一个屏幕空间的方法，通过读取深度纹理，模糊后重建表面法线，计算新的空间位置，来达到让单独的粒子变成连续液面的效果。" },
        { "type": "text", "value": "在这个项目中，为了实现 SSF 对渲染细节的修改，我使用了 SRP 可以自定义 RenderFeature 的特性，插入了一个自己编写的 RenderFeature。如果是 GPU 粒子模式，只需要关闭这个 RenderFeature 就可以回到标准的渲染模式。" },
        { "type": "text", "value": "本项目的核心点并不完全是 SPH 的算法，更重要的是性能问题。早期使用 C# 脚本（CPU 计算）时，模拟结果基本上看不出来这是流体模拟，并且粒子数量基本上不能超过千的数量级。但经过优化，现已支持超过十万数量级的粒子渲染，并且有明显的效果。所以下面是我对项目的性能和模拟过程做的优化：" },
        { "type": "text", "value": "1.GPU 加速。使用 Compute Shader 调用 GPU 计算每个粒子的各项数据，并通过 StructuredBuffer 直接传递给 Shader 进行后面的处理，全程不需要 CPU 进行中介。如果是 GPU 粒子模式下，CPU 也仅仅起到调用 DrawMeshInstancedIndirect 方法的作用。" },
        { "type": "text", "value": "2.边界处理。早期我是用的硬边界，也就是粒子到达边界直接速度反向。后来我改用边界粒子，即在边界生成不可见的，但是参与计算的粒子，这样一来，粒子在边界的行为就更加自然。" },
        { "type": "text", "value": "3.哈希算法。我实现了一种基于空间划分的哈希算法。通过将粒子划分到不同的网格中，可以快速找到相邻粒子，从而减少不必要的计算。其实这种方法跟光线追踪的 AABB 包围盒有些类似。然后我们按照 xyz 轴排序包围盒，并赋予哈希值。对于每个粒子只需要知道他所在的包围盒即可。" },
        { "type": "text", "value": "4.双调排序。上面提到哈希，但为了加快寻找，我们势必要对哈希网格进行处理。计算了粒子所在哈希网格的哈希值后，查找相邻粒子时只需要在同一个或相邻哈希网格内进行。因此，需要对粒子按哈希值进行排序，让相同哈希的粒子在数据结构中是连续的。粒子数量都是万级以上，一般的排序需要较长时间，所以我引入了双调排序，这是一种可以利用 GPU 加速的并行排序算法。" },
        { "type": "text", "value": "至于渲染的算法，前面说到已经可以将数据写入 Shader 中，如果直接渲染出来（即 GPU 粒子模式），因为 Buffer 中包含位置等信息，可以直接做 MVP 变换，提供一个渲染半径，然后片元着色器直接返回简单色即可。如果是 SSF，就是把数据进一步处理，用多个 RenderPass 实现计算深度、输出深度图、高斯模糊、采样并重建表面法线、最终着色的步骤。" },
        { "type": "image", "src": "../images/1-2.png", "alt": "渲染流程示意图" },
        { "type": "text", "value": "上图展示了渲染流程。（针对 SSF 模式）" },
        { "type": "image", "src": "../images/1-3.png", "alt": "GPU 粒子模式截图" },
        { "type": "text", "value": "上图是 GPU 粒子模式的渲染截图。" },
        { "type": "image", "src": "../images/1-4.png", "alt": "SSF 渲染模式截图" },
        { "type": "text", "value": "上图是 SSF 渲染模式的渲染截图。（这张图和 GPU 粒子模式相比，调换了视角到水面下方，因为这个天空盒下面是偏灰色，如果按照之前的视角截图，效果不明显）" },
        { "type": "video", "src": "../videos/1-1.mp4", "poster": "../videos/1-1-preface.png" },
        { "type": "text", "value": "但是，我必须承认项目还是有一些瑕疵。SSF 效果不是那么好，模糊效果会随着摄像机距离变化，我想这也是屏幕空间处理本身带来的弊端。最重要的一点就是和刚体交互时，刚体和流体的遮挡关系存在问题，尽管我尝试了各种深度检测和剔除，也努力研究代码中存在的错误，但我总感觉流体的深度和 GameObject 的深度并不在同一尺度。遮挡关系总是出错。也许是我的技术水平还不够高，或者是算法本身的局限性。总之，这个项目还有很大的改进空间。"}
        ]
    },
    {
        "id": 2,
        "title": "Fruit King - OneButton 命题作品",
        "summary": "这是一个街机游戏。限制为玩家从始至终都只能控制一个按键。设计该游戏旨在探索极简交互下的游戏体验和可玩性。作为设计者能够利用“可控制的因素”和“自动变化的因素”。",
        "type": "team",
        "public": true,
        "link": "https://github.com/MikeCFBDSIR2149/OneButton",
        "content": [
        { "type": "text", "value": "这个游戏是命题的项目，命题为 OneButton。顾名思义，只有一个按键。" },
        { "type": "text", "value": "一个按键，意味着设计的选择很有限。但我的思考是，什么是动的，什么是可控的。在这里，时间可以动，也就是说。我们可以设计倒计时，如果设计倒计时，那么意味着玩家的目标要么是通关，要么是高分。我们选择了后者，因此这个游戏的雏形就是一个街机游戏。" },
        { "type": "text", "value": "至于游戏的形式，很明显这里结合了《水果忍者》和《胡闹厨房》的机制。玩家短按空格切水果（不同的是一个水果可以切多次，每次只掉落一个水果片，所以考验手速）。但是这样的话玩家就会一直切水果了。我们势必需要一些限制。除了时间以外，我们引入了《胡闹厨房》类似的订单机制，要求玩家不能切错水果，一旦切错订单失败没有加分，并且当前订单直接结束。从游戏心理学角度，这属于“负惩罚”，也就是通过撤销订单进度和不加分，降低玩家切错的概率。玩家提交订单的方式是长按空格，所以玩家不能忘记这件事情，否则如果后面多切了也会失败。" },
        { "type": "image", "src": "../images/2-1.png", "alt": "FruitKing 游戏截图" },
        { "type": "text", "value": "上图为游戏实机截图。" }
        ],
        "comment": "这是团队项目。本人参与游戏机制的设计，并担任主程序。\\n此项目有 WebGL 演示，请点击“转到项目 WebGL 演示”以导航。",
        "externalLink": "../games/OneButton/index.html",
        "externalText": "转到项目 WebGL 演示"
    },
    {
        "id": 3,
        "title": "逐光",
        "summary": "TapTap 聚光灯 GameJam 作品。玩家控制光源发射器的方向和开关，两束光十字交汇处形成实体“光块”，玩家借助“光块”通关。",
        "type": "team",
        "alert": "本项目基于 Unity 2023.2.20f1c1。但 Unity 现已不提供该版本的服务支持。该项目受此影响，打开可能会遇到各种严重错误，并且项目可能完全无法正常运行。尝试切换到其他版本可能能够解决此问题（请注意不同版本的 API 调整），但经过测试，这可能导致场景中游戏组件的部分关键数据和索引丢失。正因此种情况，为展示方便起见，本文的部分图片和视频来自开发阶段截取。",
        "public": true,
        "link": "https://github.com/MikeCFBDSIR2149/Light",
        "content": [
        { "type": "text", "value": "本项目的风格类似于《纪念碑谷》，本质上是闯关解谜类游戏。从主题“光”，我们想到了采用两束光交汇的形式创建实体，让玩家得以通过无法通过的地方。在后续关卡中，我们结合了颜色的加法原理增添了更多游戏玩法。" },
        { "type": "image", "src": "../images/3-1.png", "alt": "关卡实机演示图 1" },
        { "type": "image", "src": "../images/3-2.png", "alt": "关卡实机演示图 2" },
        { "type": "image", "src": "../images/3-3.png", "alt": "关卡实机演示图 3" },
        { "type": "text", "value": "详细来说，前面几关光的颜色都是白色的，我们一般设计两束方向十字交叉的光源发射器，玩家需要点击发射器启动光源，让游戏主角“光球”移动到生成的光块上，然后移动或旋转发射器，让光球随之移动，达到终点“熄灭的光祭台”，光球会自动被吸附，意味着玩家通关。"},
        { "type": "text", "value": "后面几关涉及到光的颜色，我们设定光球不能在不同颜色的光块上行动，如果有光束直接照到光球上，光球会被“染色”，例如关卡四，光球初始为白色，经过绿色光染绿后，玩家才能将其移动到绿色光组成的光块上。而第五关更加复杂，玩家会多次改变颜色来找到能到达终点的道路。"},
        { "type": "text", "value": "以上是游戏核心玩法的创意设计。但这个游戏，我认为还有很多关键点也富有创意。" },
        { "type": "video", "src": "../videos/3-1.mp4", "poster": "../videos/3-1-preface.png" },
        { "type": "text", "value": "选关界面设计上，我们采用的是光投影的效果。玩家可以直观看到当前选定的关卡，并且这也符合整体游戏的美术风格。" },
        { "type": "video", "src": "../videos/3-2.mp4", "poster": "../videos/3-2-preface.png" },
        { "type": "text", "value": "注：该视频截取自开发阶段，此时按下空格会直接执行此关通关的效果。" },
        { "type": "text", "value": "我们还思考了关卡之间的连贯性。我们设计了主角作为光球开始游戏的时候，场景由暗变亮，许多光子聚集起来形成大光球，有一种“点亮”的感觉。无论玩家通关或者主动退出游戏，光球都会向外抛射光子，形成类似爆炸的效果。这样一来，关卡之间的衔接就像是光球炸开又重新聚集的感觉。" },
        { "type": "image", "src": "../images/3-4.png", "alt": "游戏暂停截图" },
        { "type": "text", "value": "游戏的暂停也经过设计，暂停时我们会让时间流速逐渐减慢，达到一种“冻结/子弹时间”的效果。进一步增强了沉浸感" },
        { "type": "text", "value": "从技术角度，这个光束本质上是一个长方体，不过加了 Shader，所以看起来像光束。光块实体的生成实际上是通过计算任意两个长方体的重合位置来实现计算实体的三棱长和位置。由于我们设定的是十字交叉，因此我们只需要用到简单的 Cube，调整其 Position 和 Scale 即可。当然，我们需要每帧更新它的数据，因为玩家可能会移动光束位置或方向。" },
        { "type": "text", "value": "关于光球爆炸和聚集的效果，实际上是采用 Visual Effect Graph，然后设计一个光球附近围绕一圈粒子，暴露围绕半径、粒子大小等数据，用代码控制。结合 Animation Curve，就可以实现看似爆炸或聚集的效果。然后再加一点后处理的变化即可。" }
        ],
        "comment": "这是团队项目。本人负责创意策划设计和后期的主要算法程序开发。\\n此项目有外部链接（TapTap 页面），请点击“转到 TapTap 游戏主页”以导航。",
        "externalLink": "https://www.taptap.cn/app/726054",
        "externalText": "转到 TapTap 游戏主页"
    },
    {
        "id": 4,
        "title": "Out Of Control（失控）",
        "summary": "本游戏尝试通过简单的设计和玩法，让玩家体会从摄像机设计到效果细节的游戏感（Game Feel），努力创造一个沉浸体验。",
        "type": "team",
        "public": true,
        "link": "https://github.com/MikeCFBDSIR2149/GameFeel",
        "content": [
        { "type": "text", "value": "游戏主要是 3D 俯视角竞速闯关，玩家操控小车转向、冲刺、跳跃，通关才能继续下一关。同时，也可以重复挑战关卡，追求更快时间的记录。" },
        { "type": "text", "value": "玩家的操纵感主要来源于我们对于“漂移感”的设计，一开始我们只是简单的让小车转向，但这样完全没有漂移的感觉。漂移是什么？后来我提出，我认为漂移的本质是车辆的朝向方向和运动方向不一致，借此，我们完善了玩家控制的“漂移感”。" },
        { "type": "text", "value": "而最特殊的机制就是在这款游戏中，作为设计者我们在部分关卡添加了一个玩家“无法一次性到达终点，必须进行‘战略性牺牲’”的机制：玩家死亡后会在原地留下一个“叉”死亡标志，玩家复活后不会消失，当玩家操控小车跳到标记上后可以再次跳跃。当玩家面对的是必然的失败时，他们可以选择在何处失败，来为下一次挑战铺路。这个“失败”不再是被动的惩罚，而是主动的、战略性的决策。" },
        { "type": "text", "value": "结合失败标记，也许玩家不止有一种过关方式。比如说，有些关卡，玩家可以不用“失败标记”，只要技术高超，能一遍通关，当然有些玩家可能选择保守的“死一次可以多一个平台供跳跃”。所以实际上我们关卡的难度是因人而异并且可以变化的。也就是说，不管是入门玩家还是高手，都会获得在不同难度和策略下的胜任感。" },
        { "type": "text", "value": "我们设计了多用户功能，引入排行榜。不同玩家可以在同一设备上彼此竞争记录，虽然不是实时竞技，也能通过分数和昵称，建立起一种微妙的社交互动。" },
        { "type": "image", "src": "../images/4-1.png", "alt": "游戏主界面" },
        { "type": "image", "src": "../images/4-2.png", "alt": "选关页（包含时间记录）" },
        { "type": "image", "src": "../images/4-3.png", "alt": "选关页（未通关）" },
        { "type": "image", "src": "../images/4-4.png", "alt": "游戏准备阶段" },
        { "type": "image", "src": "../images/4-5.png", "alt": "冲刺效果" },
        { "type": "image", "src": "../images/4-6.png", "alt": "失败效果和失败标记" },
        { "type": "image", "src": "../images/4-7.png", "alt": "跳跃效果" },
        { "type": "image", "src": "../images/4-8.png", "alt": "碰撞效果" },
        { "type": "image", "src": "../images/4-9.png", "alt": "通关效果" },
        { "type": "text", "value": "后续，我们还进行了玩家调研，收集如下反馈：" },
        { "type": "text", "value": "1.上头/红温：这显示我们的游戏有很高的游戏黏性。玩家动机很大。我们能看到玩家非常投入，并且非常愿意再试一次。因为玩家总会有这种“这次差一点，再来一次一定能过”的“幻想”。但又屡次过不去，导致不断在失败和尝试之间循环。这是一种近失效应，也是当玩家在挑战中距离成功只有一步之遥时，尽管最后还是失败了，但这种“差一点成功”的感觉会极大增强继续尝试的动机。同时也可以理解成可变比率强化，也就是玩家不知道这次什么时候能成功，就会不断尝试的结果。" },
        { "type": "text", "value": "2.难：许多参与者都给出了游戏难度高的评价。就算对于我们开发者来说，通过这些关卡也是我们在开发中一遍一遍尝试的。因此对于刚刚接触游戏的参与者来说，关卡难度曲线有些陡峭。有些关卡难度比较跳跃。这是我们设计上的一些缺陷，对于新手玩家难度设置不够合理。虽然我们有失败标记机制，但玩家总是不希望借助太多这样的机制通关。而听取反馈后，我们加入了可以随意选择关卡、不再要求顺序通关的功能。因为实践证明不同玩家擅长的关卡可能不同，可能出现前一关通不过但后一关能通过的情况。因此这样的机制是帮助玩家有更多的自我选择权，降低难度曲线的影响。" },
        { "type": "text", "value": "3.摆烂/吃保底：主要体现在，前面所说的难度问题，一些参与者开始消极使用“失败标记”机制，也就是说，他们已经不考虑怎么样快速过关，他们只是机械的一遍遍死亡并让标记铺满空白区域，机械性“铺路”，然后完成关卡。虽然这也是一种策略，通关时亦有正反馈，但意味着中间他们需要反复执行机械的死亡的步骤，实际上已经失去了游戏的兴趣，通关后也不会对下一关抱有兴趣，我认为这有点类似“习得性无助”。所以在后续的游戏优化中，我们考虑让失败标记的数量有限制（负惩罚），或者对依赖失败标记做出分数惩罚（正惩罚）。" }
        ],
        "comment": "这是团队项目。本人参与游戏操作和沉浸感的方案设计，并担任主程序。"
    },
    {
        "id": 5,
        "title": "归海",
        "summary": "CUSGA 2025 参赛作品。由于时间紧张，这个作品并非完整版。最终只把它作为一个 3D RPG 项目模版。但我在其中结合运用了 Unity 的大量功能和技术。",
        "type": "personal",
        "public": false,
        "link": "https://github.com/MikeCFBDSIR2149/3D-RPG",
        "content": [
        { "type": "text", "value": "预想中，这是一个水从海洋蒸发到陆地，经过历险之后回到海洋的故事。但实际只完成了一个场景。剧情也没有完善。" },
        { "type": "video", "src": "../videos/5-1.mp4", "poster": "../videos/5-1-preface.png"},
        { "type": "text", "value": "该项目使用的技术包括但不限于：地形系统、Timeline、Animation、Shader、后处理、Cinemachine、FSM（有限状态机）、UGUI、ParticleSystem、AudioMixer、3D 音频、文件输入输出（存档）、Input System（多设备输入和管理）、Localization（本地化）、事件委托、物理检测。" }
        ]
    },
    {
        "id": 6,
        "title": "锁链奇谜",
        "summary": "玩家将置身于鲁班锁的世界中，保持自身安全的情况下，解开鲁班锁。这是我第一次参与较为正式的项目。",
        "type": "team",
        "alert": "本项目基于 Unity 2023.2.20f1c1。但 Unity 现已不提供该版本的服务支持。该项目受此影响，打开可能会遇到各种错误。经过测试此项目运行可能不受明显影响。但如果需要避免错误提示，尝试切换到其他版本可能能够解决此问题（请注意不同版本的 API 调整）。",
        "public": true,
        "link": "https://github.com/MikeCFBDSIR2149/GameDev1",
        "content": [
        { "type": "text", "value": "游戏主要是玩家控制一个生成在鲁班锁的角色，触发机关，解开鲁班锁即为通关。但我们添加了一些特别设计——玩家必须保证自身安全。因为移动一些机关可能会导致角色掉下去，这样一来，游戏的趣味性和复杂性进一步提升。" },
        { "type": "image", "src": "../images/6-1.png", "alt": "教程关图 1" },
        { "type": "image", "src": "../images/6-2.png", "alt": "教程关图 2" },
        { "type": "image", "src": "../images/6-3.png", "alt": "关卡 1 截图" },
        { "type": "image", "src": "../images/6-4.png", "alt": "关卡 2 截图" }
        ],
        "comment": "这是团队项目。本人主要负责策划设计，少量参与程序部分。"
    }
]